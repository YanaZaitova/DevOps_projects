  **`D01_Linux. Установка и обновления системы Linux. Основы администрирования.`**

- [`Part 1. Установка ОС`](#part-1-установка-ос)
- [`Part 2. Создание пользователя`](#part-2-создание-пользователя)
- [`Part 3. Настройка сети ОС`](#part-3-настройка-сети-ос)
- [`Part 4. Обновление ОС`](#part-4-обновление-ос)
- [`Part 5. Использование команды sudo`](#part-5-использование-команды-sudo)
- [`Part 6. Установка и настройка службы времени`](#part-6-установка-и-настройка-службы-времени)
- [`Part 7. Установка и использование текстовых редакторов`](#part-7-установка-и-использование-текстовых-редакторов)
- [`Part 8. Установка и базовая настройка сервиса `**`SSHD`**](#part-8-установка-и-базовая-настройка-сервиса-sshd)
- [`Part 9. Установка и использование утилит` **`top`**, **`htop`**](#part-9-установка-и-использование-утилит-top-htop)
- [Part 10. Использование утилиты **fdisk**](#part-10-использование-утилиты-fdisk)
- [`Part 11. Использование утилиты` **`df`**](#part-11-использование-утилиты-df)
- [`Part 12. Использование утилиты` **`du`**](#part-12-использование-утилиты-du)
- [`Part 13. Установка и использование утилиты `**`ncdu`**](#part-13-установка-и-использование-утилиты-ncdu)
- [`Part 14. Работа с системными журналами`](#part-14-работа-с-системными-журналами)
- [`Part 15. Использование планировщика заданий` **`CRON`**](#part-15-использование-планировщика-заданий-cron)

#
## `Part 1. Установка ОС`
#


> **Задание**
> 
> `Установить` **`Ubuntu 20.04 Server LTS`** `без графического интерфейса. (Используем программу для виртуализации - VirtualBox)`

Узнать версию Ubuntu можно, выполнив команду:

```
cat /etc/issue
```
![ubuntu version](./images/1.png)

#
## `Part 2. Создание пользователя`
#


> **Задание**
> 
> `Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен иметь разрешение на прочтение логов из папки /var/log.`

Создание пользователя осуществляется командой:

```
sudo adduser logvarviwer
```
Вызов в терминале:

![create logvaruser](./images/2.png)

Наш новый пользователь в выводе команды: 
```
cat /etc/passwd:
```

![cat /etc/passwd command](./images/3.png)

#
## `Part 3. Настройка сети ОС`
#
> **Задание**
> 
> * `Задать название машины вида user-1`
> * `Установить временную зону, соответствующую вашему текущему местоположению.`
> * `Вывести названия сетевых интерфейсов с помощью консольной команды.`
> * `В отчёте дать объяснение наличию интерфейса lo.`  
> * `Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера.` 
> * `В отчёте дать расшифровку DHCP.`  
> *  `Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw).` 
> * `Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8).` 
> * `Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте.`
> * `В отчёте описать, что сделано для выполнения всех семи пунктов  (можно как текстом, так и скриншотами).`
> * `Успешно пропинговать удаленные хосты 1.1.1.1 и ya.ru и вставить в отчёт скрин с выводом команды.`

Для того чтобы изменить название машины используем команду:
```
sudo hostnamectl set-hostname logvarviwer-1
```
![hostnamectl logvarviwer-1](./images/4.png)

После перезагрузки виртуальной машины видим подтверждение, что команда отработала корректно:

![hostname logvarviwer-1](./images/5.png)

Для выполнения следующего задания смотрим текущий часовой пояс c помощью утилиты:
```
timedatectl
```
![current timezone](./images/6.png)

 Выводим список доступных часовых поясов:
```
timedatectl list-timezones
```
В списке доступных временных зон находим нужный:

![our timezone](./images/8.png)

Для установления временной зоны, соответствующей нашему текущему местоположению применяем команду:

```
 timedatectl set-timezone Asia/Novosibirsk
```
![chanched timezone](./images/9.png)

Названия сетевых интерфейсов получаем и выводим по команде:
```
ip link show
```
![network interface](./images/10.png)

 *`lo(loopback)`* – это петлевой интерфейс, который используется для локального доступа ко всем сетевым сервисам. Это средство межпроцессного обмена информацией только для локальных(внутренних) процессов.

Получение ip адреса устройства от DHCP сервера осуществляется командой:

```
ip route
```
![dhcp ip](./images/11.png)

 *`DHCP(Dynamic Host Configuration Protocol)`* - прикладной протокол, выполняющий всю работу по подбору сетевых настроек автоматически, без необходимости присваивать вручную каждому устройству свой IP-адрес.

Внутренний  ip адрес шлюза определяем командой и производим поиск при помощи grep:

```
ip route | grep default
```
![ip default](./images/12.png)

Внешний ip адрес выводим командой:

```
curl ifconfig.me/ip
```
![ip](./images/13.png)

Средством управления сетью по умолчанию в Ubuntu является *`netplan`* 

В папке /etc/netplan находим конфигурационный файл с расширением .yaml 
```
ls /etc/netplan
```
![ls netplan](./images/14.png)

Задать статичные настройки ip, gw, dns можно при помощи редактирования файла .yaml в виме

```
sudo vim /etc/netplan/00-installer-config.yaml
```
![vim config.yaml](./images/15.png)

![vim fixed config.yaml](./images/16.png)
Режим редактирования: клавиша `i`,

Выйти из режима редактирования: `esc`,

Выйти из вим с сохранением: `wq`

Применяем изменения, чтобы при перезагрузке ВМ, внесенные нами данные сохранились

```
sudo netplan apply
```
![netplan apply](./images/17.png)
После перезагрузки системы смотрим, что наши настройки сохранились:

```
ip a
```
![new settings](./images/18.png)
Для того, чтобы успешно пропинговать удаленные хосты 1.1.1.1 и ya.ru вводим команды:
```
ping -c 5 1.1.1.1
```
![ping 1.1.1.1](./images/19.png)
```
ping -c 5 ya.ru
```
![ping ya.ru](./images/20.png)

-`с` - количество пакетов, которые нужно отправить; 
#
## `Part 4. Обновление ОС`

**Задание**

> `Обновить системные пакеты до последней на момент выполнения задания версии.`  
`Узнаем, какие пакеты обновлений нам доступны, для этого обновляем репозиторий Ubuntu`

```
sudo apt update
```
![sudo apt update](./images/21.png)

Используем следующую команду для установки обновлений:

```
sudo apt upgrade
```
![sudo apt upgrade](./images/22.png)

На скриншотах мы видим процесс выполнения вышеуказанных команд.

Проверяем, что все обновления установлены и новых больше нет.

![sudo apt update again](./images/23.png)

#
## `Part 5. Использование команды sudo`
#
> **Задание**
> 
> `Разрешить пользователю, созданному в ` [Part 2](#part-2-создание-пользователя)`, выполнять команду sudo.`


Для разрешения пользователю, созданному в `Part 2` , выполнения команды sudo в командной строке пропишем:

```
sudo usermod -aG sudo logvarviwer
```
![logvarviwer usermod](./images/24.png)

 *`Значение команды sudo:`* 
  Использование sudo позволяет выполнять привилегированные команды обычным пользователям без необходимости ввода пароля суперпользователя root. Настройки sudo позволяют реализовать гибкую систему распределения полномочий отдельных пользователей в многопользовательской среде.

 Hostname OC поменяем уже использованной нами в Part3 командой 
```
sudo hostnamectl set-hostname logvarviwer
```
![logvarviwer hostname](./images/25.png)
Перезагружаем машину, смотрим, что шалость удалась.
![logvarviwer hostname](./images/26.png)
#
## `Part 6. Установка и настройка службы времени`
#

> **Задание**
> 
> `Настроить службу автоматической синхронизации времени. ` 
> 
> - `Вывести время, часового пояса, в котором вы сейчас находитесь.`
> 
> - `Вывод следующей команды должен содержать NTPSynchronized=yes:  timedatectl status`
> 
>- `Вставить скрины с корректным временем и выводом команды в отчёт.`

Выводим время и текущий часовой пояс:

```
timedatectl
```
![timedatectl](./images/27.png)

```
timedatectl show
```
![timedatectl](./images/28.png)
#
## `Part 7. Установка и использование текстовых редакторов`
#
> **Задание**
> 
> `Установить текстовые редакторы` **`VIM`** `(+ любые два по желанию` **`NANO`**`,` **`MCEDIT`**`,` **`JOE`**` и т.д.)  `
> `Используя каждый из трех выбранных редакторов, создайте файл` *`test_X.txt`*`, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений.`
> - `В отчёт вставьте скриншоты:`
> - `Из каждого редактора с содержимым файла перед закрытием.`
> - `В отчёте укажите, что сделали для выхода с сохранением изменений.`
> - `Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений.`
> - `В отчёт вставьте скриншоты:`
> - `Из каждого редактора с содержимым файла после редактирования.`
> - `В отчёте укажите, что сделали для выхода без сохранения изменений.`
> 
> `Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое.`
> - `В отчёт вставьте скриншоты:`
> - `Из каждого редактора с результатами поиска слова.`
> - `Из каждого редактора с командами, введёнными для замены слова на другое.`

```
sudo apt install vim nano mc
```
![install vim nano mc](./images/29.png)

Создаем файлы: 
```
vim test_vim.txt
```
![vim test_vim.txt](./images/31.png)

Чтобы войти в режим редактирования - `i`

Чтобы выйти из режима редактирования - `esc`

Чтобы выйти с сохранением изменений - `:wq` и `enter`

![cat test_vim.txt](./images/34.png)
```
nano test_nano.txt
```
![nano test_nano.txt](./images/32.png)

Чтобы сохранить изменения - `Ctrl + O`

Чтобы выйти - `Ctrl + X`.

![cat test_nano.txt](./images/35.png)

```
mcedit test_mcedit.txt
```
![mcedit test_mcedit.txt](./images/33.png)
Чтобы сохранить изменения - `esc`, `F2`

Чтобы выйти - `F10`.

![cat test_mcedit.txt](./images/36.png)
Убеждаемся, что файлы созданы и хранятся в директории:

![ls vim nano mc](./images/30.png)

![chanched test_vim.txt](./images/37.png)

Для выхода в виме без сохранения изменений: `:q!`

![chanched test_nano.txt](./images/38.png)
Для выхода в nano без сохранения изменений: `ctrl+X`, `N`

![chanched test_mcedit.txt](./images/39.png)

![chanched-1 test_mcedit.txt](./images/40.png)
Для выхода в mcedit без сохранения изменений: `esc`, после `F10` и `No` в выборе сохранения изменений и `enter`

***Для выполнения следующего задания никнейм omarsha будет заменяться на lovepeace.***

`Для vim'а:`

Для поиска и последующей замены слова можно использовать шаблон

```
:s/search/substitution
```
 где `search` - искомое слово, а `substitution` - его замена.

![find test_vim.txt](./images/41.png)

 Нажимаем `enter`

![replace test_vim.txt](./images/42.png)

`Для nano:`

Для запуска поиска в nano необходимо нажать `ctrl+\`(\ у кнопки enter), далее следовать подсказкам nano
![find test_nano.txt](./images/43.png)

![replace test_nano.txt](./images/44.png)


`Для mcedit:`

Нажать `fn+F4` и далее следовать подсказкам mcedit:
![find test_mcedit.txt](./images/45.png)

![replace test_mcedit.txt](./images/46.png)

![replace test_mcedit.txt](./images/47.png)
#
## `Part 8. Установка и базовая настройка сервиса `**`SSHD`**
#
> **Задание**
> 
> - `Установить службу SSHd.`  
> - `Добавить автостарт службы при загрузке системы.`
> - `Перенастроить службу SSHd на порт 2022.` 
> - `Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи.`
> - `В отчёте объяснить значение команды и каждого ключа в ней.`
> `Перезагрузить систему.`
> - `В отчёте опишите, что сделали для выполнения всех пяти пунктов (можно как текстом, так и скриншотами).`
> - `Вывод команды netstat -tan должен содержать  \`
`tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN \`
`(если команды netstat нет, то ее нужно установить)`
> - `Скрин с выводом команды вставить в отчёт.`
> - `В отчёте объяснить значение ключей -tan, значение каждого столбца вывода, значение 0.0.0.0.`

Для установки службы SSHd пропишем в консоли команду:
```
sudo apt install openssh-server
```
![install openssh-server](./images/48.png)

![2 install openssh-server](./images/49.png)

Для добавления службы в автостарт при запуске системы используем команду:

```
sudo systemctl enable ssh.service
```
![ systemctl openssh-server](./images/50.png)

Для перенастройки службы SSHd на порт 2022 откроем конфиг службы в виме и изменяем порт:

```
sudo vim /etc/ssh/sshd_config
```
![chanched port openssh-server](./images/51.png)

Показывать наличие запущенных процессов будем с помощью ps с флагом  -e
```
ps -e | grep ssh
```
,где `-e` -  выдает информацию обо всех запущенных процессах

![ps ssh](./images/52.png)

Команда ps выводит список текущих процессов на сервере. Используется обычно в сочетании с командой grep и/или more или less.

Далее перезагружаем машину:

```
reboot
```
![reboot VB](./images/53.png)


По заданию вызываем команду `netstat` с флагами
```
netstat -tan
```
Команда `netstat` выводит данные о сетевых соединениях, таблице маршрутизации, статистику сетевых интерфейсов, маскированных соединений.

Флаг `-t` - отсортировывает протокол tcp, 

`-a` - показывает прослушиваемые и непрослушиваемые порты,

`-n` - показываeт числовое представление адресов.

![netstat -tan](./images/54.png)

Значение каждого столбца:

- `Proto` - Протокол (tcp, udp, raw), используемый сокетом.
- `Recv-Q` - Счётчик байт не скопированных программой пользователя из этого сокета.
- `Send-Q` - Счётчик байтов, не подтверждённых удалённым узлом.
- `Local Address` - Адрес и номер порта локального конца сокета. Если не указана опция --numeric (-n), адрес сокета преобразуется в каноническое имя узла (FQDN), и номер порта преобразуется в соответствующее имя службы.
- `Foreign Address` - Адрес и номер порта удалённого конца сокета. Аналогично *Local Address*.
- Нулевой адрес сокета (0.0.0.0 или :::) говорит о том, что подключение отсутствует.
- `State` -  Состояние сокета. 
 *LISTEN* - Сокет ожидает входящих подключений.

*Сокет* (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.

#
## `Part 9. Установка и использование утилит` **`top`**, **`htop`**
#
 
> **Задание**
> 
> `Установить и запустить утилиты top и htop. ` 
> - `По выводу команды top определить и написать в отчёте:`
>  - `uptime`
>  - `количество авторизованных пользователей`
>  - `общую загрузку системы`
>  - `общее количество процессов`
>  - `загрузку cpu`
>  - `загрузку памяти`
>  - `pid процесса занимающего больше всего памяти`
>  - `pid процесса, занимающего больше всего процессорного времени`
> - `В отчёт вставить скрин с выводом команды htop:`
>  - `отсортированному по PID, PERCENT_CPU, PERSENT_MEM, TIME`
>  - `отфильтрованному для процесса sshd`
>  - `с процессом syslog, найденным, используя поиск`
>  - `с добавленным выводом hostname, clock и uptime` 

Утилита top уже была предустановлена на VB. Сразу запускаем

```
top
```
![top](./images/56.png)

> - *Описание вывода команды top*:
>  - uptime - 1
>  - количество авторизованных пользователей - 1 user
>  - общая загрузку системы - 0.11 за последнюю минуту
>  - общее количество процессов - 114 шт
>  - загрузка cpu - 0.0%
>  - загрузка памяти - 198.5 used
>  - pid процесса занимающего больше всего памяти -  902
>  - pid процесса, занимающего больше всего процессорного времени - 902

Устанавливаем утилиту `htop`

```
sudo apt install htop
```
![install htop](./images/55.png)

```
htop
```
![htop](./images/57.png)

Сортировать можно, используя F6, стрелки вверх-вниз и enter:

Вывод команды htop отсортированному по PID

![htop sort](./images/58.png)
![htop pid](./images/59.png)

, PERCENT_CPU:
![htop cpu](./images/60.png)

, PERSENT_MEM:
![htop mem](./images/61.png)

, TIME:
![htop time](./images/62.png)

Вывод команды htop отфильтрованному по sshd:

![htop sshd](./images/63.png)

С выводом syslog, найденным через поиск:

![htop syslog](./images/64.png)

Для вывода clock, uptime, hostname используем `fn+F2` и добавляем нужные нам характеристики.

![htop clock, uptime, hostname](./images/65.png)
#
## Part 10. Использование утилиты **fdisk**
#

> **Задание**
> 
> `Запустить команду fdisk -l.`


> - название жесткого диска - VBOX HARDDISK, 
> - его размер - 16 GiB,
> - количество секторов - 33554432,
> - размер swap - 1,9 GiB.

```
fdisk -l
```
![fdisk -l](./images/66.png)

```
free -h
```
![free -h](./images/67.png)

#
## `Part 11. Использование утилиты` **`df`** 
#
> **Задание**
>
> `Запустить команду df. ` 
 
```
df
```
![df](./images/68.png)

Корневой раздел (/):
  - размер раздела - 16445308 Kib,
  - размер занятого пространства - 5355420 Kib,
  - размер свободного пространства - 10234800 Kib,
  - процент использования - 35%.
- Единицы измерения -  Kib.

> Запустить команду df -Th.

```
df -Th
```
, где 

`-T` - выводит информацию о файловой системе.

`-h` - печатает размер в человекочитаемом виде.

![df](./images/69.png)

Для корневого раздела (/):
  - размер раздела -  16 Gib,
  - размер занятого пространства -  5.2 Gib,
  - размер свободного пространства - 9.8 Gib,
  - процент использования - 35%.
  
 Тип файловой системы для раздела - `ext4`.


#
## `Part 12. Использование утилиты` **`du`**
#
> **Задание**
> 
> `Запустить команду du.`

```
du
``` 

![du](./images/70.png)

Размер папок в байтах, в человекочитаемом виде:
```
sudo du -sh [path]
```
, где 

`s` - выводит общий размер папки.

`h` - печатает размер в человекочитаемом виде.

Папка `/home`
```
sudo du -sh /home
```
![du /home](./images/71.png)

Папка `/var`
```
sudo du -sh /var
```
![du /var](./images/72.png)


Папка `/var/log`

```
sudo du -sh /var/log
```
![du /home](./images/73.png)

Файлы `/var/log/*`
```
sudo du -ha /var/log/* | more
```
![du /home](./images/77.png)
![du /home](./images/74.png)
![du /home](./images/75.png)
![du /home](./images/76.png)

`a` - выводит файлы.
#
## `Part 13. Установка и использование утилиты `**`ncdu`**
#

> **Задание**
> 
> `Установить утилиту ncdu.`

```
sudo apt install ncdu
```
![sudo apt install ncdu](./images/78.png)

Выводим размер папок /home, /var, /var/log
```
ncdu /home
```
![ncdu /home](./images/79.png)

```
ncdu /var
```
![ncdu /var](./images/80.png)

```
ncdu /var/log
```

![ncdu /var](./images/81.png)

#
## `Part 14. Работа с системными журналами`
#

**Задание**

> `Открыть для просмотра:` 
> 1. /var/log/dmesg
> 2. /var/log/syslog
> 3. /var/log/authlog  

```
less /var/log/dmesg
```
![less /var/log/dmesg](./images/83.png)
![less /var/log/dmesg 2](./images/84.png)
 
Остальные по аналогии.
Данные о последней успешной авторизации получаем через команду:
```
less /var/log/auth.log | grep -e login
```
![login info](./images/82.png)
Время последней успешной авторизации - 17:11:04,

имя пользователя - logvarviwer,

метод входа в систему - by LOGIN.

Перезапуск SSHd осуществляем командой:

```
sudo systemctl restart ssh.service
```
![restart SSHd](./images/85.png)

```
sudo tail -n 7 /var/log/syslog
```
![sshd info](./images/86.png)

#
## `Part 15. Использование планировщика заданий` **`CRON`**
#


> **Задание**
> 
> `Используя планировщик заданий, запустите команду uptime через каждые 2 минуты.`
> - `Найти в системных журналах строчки (минимум две в заданном временном диапазоне) о выполнении.`
> - `Вывести на экран список текущих заданий для CRON.`
> - `Вставить в отчёт скрины со строчками о выполнении и списком текущих задач.`
> 
> `Удалите все задания из планировщика заданий.`

Команда для создания или изменения существующего crontab-файла:

```
crontab -e
```

Выбираем текстовый редактор для работы с файлом из списка предложенных и добавляем uptime:

![crontab -e](./images/87.png)

![crontab nano](./images/88.png)

Записи о запуске задачи в системном журнале:
```
sudo tail -n 7 /var/log/syslog
```

![crontab logs](./images/89.png)

Выполняем команду и удаляем все существующие задачи:

```
crontab -e
```
![delete update task](./images/90.png)


